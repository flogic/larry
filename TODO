 -> should auto-populate missing required parameters into parameters when editing services
 -> should segregate parameter editing into 2 parts: service-required and unknown (with unknown at the bottom by the add link)
 -> controller for handling instance parameter editing data

 -> should be able to edit service parameter requirements from service view

 - computation of "possible to deploy" would be dependent upon parameter assignments being met, so, write Instance#can_deploy? with just this conditional so far

 - move computation of manifest and/or configuration into Instance -- Host methods should just be wrappers

 - change parameter computation in Instance (recently moved from host) so that it pulls parameter values from the Instance

 ---

 ??? should be able to see service parameter assignments for an instance from some instance detail view (i.e., here's how the services will be / were deployed).  That is, here's service detail, and when these services were deployed (will be deployed) they got assignments like this.  I feel like this might be a hidden model emerging -- the deployment set, or deployment event.

 ??? parameters could be computed from host (e.g., ip addresses, etc.) ... does this imply bad design of the manifest/recipe that enforces them?  (maybe) ... what about multiple IP addresses for, say, multiple SSL domain names for a web app?
 
 ---

 -> start implementing Destination stuff (see below) so we can make Instance#can_deploy? more meaningful

 -> deploy.  This may imply that we have a state machine associated with deployments (associated with instances/services).  This would also imply that getting deployment feedback (e.g., the puppet-reporter "report" data closing the loop, if that's possible; or monitoring information being able to be fed back in; both are tricky but at least one of them would be highly useful, imo)

 - Q: is the difference between a service that's required by many instances on a host (e.g., postgres) but which only really causes one installation to happen, vs. services that have the same name but differ in parameters and cause multiple things to happen (e.g., setting up a postgres *database* for an app) ... is this something larry needs to concern itself with, or do we just leverage the underlying management tool?  If we're using puppet, puppet can sort things out, but it's not clear that something like chef, e.g., can.
 
 -> would be useful for customer, app, instance to have deployed? predicates so that we can know if they are deployed anywhere

 *** -> brainstorming:  we could aggregate a set of Deployments by a Time Period, which reflects an interval in time when this deployment was true, is & will be true, or will be true in the future.  We could also archive off a deployment set (even if we do nothing else with it) to generate a deployment history.  This could make reversion to a prior state possible.
---

 "Audits":  aka, Service linkages that use Destinations to compute which Hosts they are to be deployed to (e.g., monitoring, backups, firewall rules, logrotate, etc.).  Services *about* other services.
  
 ... Q:  is there any reason not to use Destinations for *all* deployments?  Meaning that audits are only distinguished then by their deployments' explicit association (aboutness) with another deployment.

 - Currently we model the instance -> deployment -> host relationship in such a way that we presume every service for an instance is deployed to the same host; audits make this untrue, and hence the cardinality of the instance -> host(s) relationship also has to increase, as well as the cardinality of instance -> deployment ... need to revisit the domain_model graphic
 
 - so, this is where host classification might actually be useful.  Make various host classes ("database server", "web server", "high throughput box", etc.), then have Destinations for Services be by host class membership.
 
 - note also that host class membership may set a floor on the type of provisioning we can do (or, at least, could say, this host class requires something of this size or larger, cf, the rubycloud notion of per-provider flavors, and so any of the flavors mapped to this size or larger could suffice)

 ---
 
 -> operations:  un-deploy, deploy, shut down, start host, provision new host, etc. (what impact do these have out in the world?)

 -> we should enforce that only top-level services are linked to instances, everything else is computed ... this means that when edges are created, or when services are linked/unlinked from instances that there may be a cascade of changes to the service set for an instance, which may cascade to deployments, which may cascade out to various hosts -- this would work best if we live in a do/undo world of host deployment (e.g., the way stahnma is setting up puppet manifests)
 
 -> looks like services controller doesn't have specs for the alternate formats being delivered

 -> could have indexes identify strange situations:  customers with undeployed apps, hosts with no deployments, apps which are not deployed, etc.

 -> I think the puppet-classifer "class"/"service" modeling did a disservice to what I'm trying to do.  Need to unwind this.

 -> there should be a services method for hosts, so that we can easily see what services are supposed to be on the host.  The deployments are, in a sense, the detailed "Actually deployed on the host" services.  So, in a sense, the services are being linked via destinations to deployments on hosts (if the destination is a same-host destination then destination is almost a no-op way to get from service to deployment, which belongs_to host)

 -> generate some sort of YAML dump
 -> import data from YAML dump
 -> probably useful to have a display of services that are not deployed for instances (why did we not deploy the searchd for this site?)
 -> favicon.ico, heh
 
 ---

 -> add linkages to nagios details for a host, service, etc.
 -> add linkages from customers to invoicing, e.g.
 -> is it possible to link from apps (or instances) to github pages?
 -> is it possible to link apps / customer to trouble ticket pages?
 -> what about linking to PT, e.g.
 
 : this probably speaks to a general facility to associate an URL with a class (customer, app, instance, deployment, host, etc.); in which case it might well be possible to have parsers for the data at the end of those URLs so that we could aggregate data; if we push out RSS, e.g., from larry then it would be possible for larry to be a central dashboard.
