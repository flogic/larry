
 -> link to edit customer from show page
 -> cancel or show customer from edit page

 -> default "%h3 no <whatever>" conditional on index pages for { customers, apps, instances, hosts, services }

 -> add host 
 -> edit host

 -> add customer app
 -> edit app
 -> add app instance
 -> edit instance

 -> delete customer (requires safe_to_delete? predicate on customer)
 -> delete host (ditto)
 
 ---
 
 "Audits":  aka, Service linkages that use Destinations to compute which Hosts they are to be deployed to (e.g., monitoring, backups, firewall rules, logrotate, etc.).  Services *about* other services.
  
 ... Q:  is there any reason not to use Destinations for *all* deployments?  Meaning that audits are only distinguished then by their deployements' explicit association (aboutness) with another deployment.

 - Currently we model the instance -> deployment -> host relationship in such a way that we presume every service for an instance is deployed to the same host; audits make this untrue, and hence the cardinality of the instance -> host(s) relationship also has to increase, as well as the cardinality of instance -> deployment ... need to revisit the domain_model graphic

 --- 

 -> parameters for services
 -> bubble-up of parameters for services to instances for setting (implies that when we generate a service+parameter list we down-propagate, filling in variables)
 -> parameters being complete are a pre-condition for being able to deploy an instance
 -> parameters could be computed from host (e.g., ip addresses, etc.) ... does this imply bad design of the manifest/recipe that enforces them?  (maybe) ... what about multiple IP addresses for, say, multiple SSL domain names for a web app?

 ---

 -> deploy.  This may imply that we have a state machine associated with deployments (associated with instances/services).  This would also imply that getting deployment feedback (e.g., the puppet-reporter "report" data closing the loop, if that's possible; or monitoring information being able to be fed back in; both are tricky but at least one of them would be highly useful, imo)

 - Q: is the difference between a service that's required by many instances on a host (e.g., postgres) but which only really causes one installation to happen, vs. services that have the same name but differ in parameters and cause multiple things to happen (e.g., setting up a postgres *database* for an app) ... is this something larry needs to concern itself with, or do we just leverage the underlying management tool?  If we're using puppet, puppet can sort things out, but it's not clear that something like chef, e.g., can.
 
 -> would be useful for customer, app, instance to have deployed? predicates so that we can know if they are deployed anywhere

 -> operations:  un-deploy, deploy, shut down, start host, provision new host, etc. (what impact do these have out in the world?)

 -> we should enforce that only top-level services are linked to instances, everything else is computed ... this means that when edges are created, or when services are linked/unlinked from instances that there may be a cascade of changes to the service set for an instance, which may cascade to deployments, which may cascade out to various hosts -- this would work best if we live in a do/undo world of host deployment (e.g., the way stahnma is setting up puppet manifests)

 ?-> deletion links (rules about deployed or not)
 ?-> views (show, index, _summary) for deployments ?, destinations ?
 
 -> looks like services controller doesn't have specs for the alternate formats being delivered

 -> could have indexes identify strange situations:  customers with undeployed apps, hosts with no deployments, apps which are not deployed, etc.

 -> I think the puppet-classifer "class"/"service" modeling did a disservice to what I'm trying to do.  Need to unwind this.

 -> there should be a services method for hosts, so that we can easily see what services are supposed to be on the host.  The deployments are, in a sense, the detailed "Actually deployed on the host" services.  So, in a sense, the services are being linked via destinations to deployments on hosts (if the destination is a same-host destination then destination is almost a no-op way to get from service to deployment, which belongs_to host)

 -> generate some sort of YAML dump
 -> import data from YAML dump

 -> probably useful to have a display of services that are not deployed for instances (why did we not deploy the searchd for this site?)

 -> paginate index pages?  We'll see
 
 -> favicon.ico, heh
 
 ---

 -> add linkages to nagios details for a host, service, etc.
 
 -> add linkages from customers to invoicing, e.g.
 
 -> is it possible to link from apps (or instances) to github pages?
 -> is it possible to link apps / customer to trouble ticket pages?
 -> what about linking to PT, e.g.
 
 : this probably speaks to a general facility to associate an URL with a class (customer, app, instance, deployment, host, etc.); in which case it might well be possible to have parsers for the data at the end of those URLs so that we could aggregate data; if we push out RSS, e.g., from larry then it would be possible for larry to be a central dashboard.
