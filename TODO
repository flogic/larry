
["D" -> deployment milestone]
["P" -> provisioning milestone]

 D create pool (name, description)
 D validate pool name presence, uniqueness
 D hosts many:many with pool (:through model: PoolMembership)
 D pool menu links
 D pool index view
 D pool new view, pool edit view
 D pool show view (includes hosts)
 D hosts show view includes pool memberships
 D pool show view should allow adding host, removing hosts
 D host show view should allow adding to pool, removing from pool

 ---
 
 D instance show view would include a "Deploy this" link for an instance which #can_deploy?  Goes to deployments/new, providing this instance as a member of instance list
 D deployments/new view can accept a list of instances (add another instance, w/ dropdown to choose)
 D deployments/new can accept a start time (default now), and end time (default nil)
 D deployments/new has a Pool chooser (requires a Pool)
 D deployments has a Reason field (mandatory) which explains why this deployment happened
 D creates a new Deployable, as well as a Deployment when done
   - Deployable stores service list, parameters, instances, and this new deployment
 D Host manifest generation functionality needs to be updated so that it checks currently active Deployments for the host and uses them to generate manifests
 D deployments/new front-end should include an option to choose from old Deployables, otherwise we're creating a new Deployable
 D ideally deployments/new can limit old deployments by instance
 D Instance show view should show current deployments
 D Instance show view should show future deployments
 D Instance show view should show past deployments
 D Deployments show view, index view
 D Deployables show view, index view
 D I don't think it makes sense to edit a deployment or a deployable, does it?
 D stop a deployment
 D link from deployables/show (maybe also deployables/index) to make a new deployment from that deployable
 
 D deployed services are created which show how services got put on hosts (via deployments)
 D should be able to see services deployed to a Host
 D also, should be able to generate a history of a Host wrt services
 D at some point, deal with audits and audit deployments
 
 ---

 P we can provision hosts that don't exist
 P we can provision hosts into a pool
 P we can ask a pool to provision hosts
 P hosts can have capacities, so that we can estimate whether we have enough capacity for deploying instances
 P instances can have costs, so that we can determine if we have sufficient host resources to deploy instances
 P should be able to determine if a pool has sufficient capacity to deploy instance(s)
 P should be able to recommend hosts to provision
 P [ provision would be via rubycloud, etc. ]
 P when deploying, should recommend hosts for instances, but provide a way to choose another host, or to provision a new host.
 P provisioning is based on capacity/cost, fwiw
 P could presumably associate a floor capacity w/ a Role

 thoughts:
 
 - we can mark various things (instance, app, customer, host, ?) as "dirty" on changes, and save them up for a deployment, so that we can know if our planned changes have been put into action, know when we need to make a deployment, can batch up changes, and keep the process of creating deployments separate from the data which is used to do current production deployments
 - should be able to specify that certain instances not reside on the same host
 - should be able to specify that certain instances should reside on the same host
 - should be able to specify that a service (or at least, an audit) should be on the same host as another (think log rotation, e.g.)
 - may want to be able to specify that a services (or at least, an audit) should not be on the same host as another ... or maybe it's that audits have their own Requirements for deployment?
 - could have indexes highligh strange situations:  customers with undeployed apps, hosts with no deployments, apps which are not deployed, etc.
 - we can snapshot an instance (i.e., use it as a template); if we make a new instance we basically make the instance, set snapshot_id (or whatever) to the template instance, then delegate things to the template; we make the template instance's parameter values be defaults (behind customer, app, instance).
 - presumably we could also snapshot an app; we could either go the same route (have a template pointer to the template app), or we could just instantiate new instances using the old app's instances as template.
 - general facility to associate remote resources with a concept (maybe w/ a parser, and we can generate an RSS feed)
   -> add linkages to nagios details for a host, service, etc.
   -> add linkages from customers to invoicing, e.g.
   -> is it possible to link from apps (or instances) to github pages?
   -> is it possible to link apps / customer to trouble ticket pages?
   -> what about linking to PT, e.g.
 - favicon.ico, heh
 
 - since deployment records are captured we can do rollbacks
 - since deployment records are captured we can run a tool like puppet consistently over them without fear of introducing changes
 - since deployment manifests can only change when a deployment is created or on the time-interval boundaries of the deployments, we don't have to continuously poll for changes (i.e., we could schedule and/or notify instead).

--- Questions

 Q: are there parameters for services that would be accepted but are not required (i.e., they should auto-fill in our instance parameter list, but not display as "required", and a can_deploy? call would ignore them)?
  
 Q: is the difference between a service that's required by many instances on a host (e.g., postgres) but which only really causes one installation to happen, vs. services that have the same name but differ in parameters and cause multiple things to happen (e.g., setting up a postgres *database* for an app) ... is this something larry needs to concern itself with, or do we just leverage the underlying management tool?  If we're using puppet, puppet can sort things out, but it's not clear that something like chef, e.g., can.
