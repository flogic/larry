["D" -> deployment milestone]
["P" -> provisioning milestone]

   D add { Customer }#all_{deployments, deployed_services, hosts } which return records regardless of whether they are current
   
  D make sure that the all_* methods for { Customer, App, Instance, Deployable, Host } return their instances in order of deployment start_date
     
  (for creation of deployment/deployable... maybe we just make an instance/deploy controller method that tries to integrate the other two models? or we look at doing a presenter?)
   
 - new deployment interface
   D deployments/new should have a Reason field (mandatory) which explains why this deployment happened
   D deployments/new can accept a start time (default now), and end time (default nil)
   D choose a host on which to deploy the instance (this is where Requirements, Pools, and Provisioning smarts come in later)
   D show instance information on deployments/new form
   D show current deployments of this Instance on deployments/new page 
   D show historical deployments of this Instance (including which Deployable version they used)
   D deployments/new front-end should include an option to choose from old Deployables, otherwise we're creating a new Deployable
   D deployments/new would only allow choosing old Deployables for this Instance
 
 D deployable - before_saving, snapshot the service + parameters data so that we can do a deployment
 D if there is already an active Deployment for this Instance on that Host,  we want to truncate its end time if there is overlap
 D provide warning if the same host is chosen as a current Deployment that we'll be ending that deployment
 D deployed services are created which show how services got put on hosts (via deployments) 
 - Deployable stores service list, parameters, instance (meaning we're free from then on out to change services, instances, parameters, etc.)
 D Deployments can be edited so long as they are in the future, ditto deleted
 D Host manifest generation functionality needs to be updated so that it checks currently active Deployments for the host and uses them to generate manifests (active means start time <= now, and end_time > now)
 D Instance show view should show Deployables
 D Instance show view should show current deployments
 D Instance show view should show future deployments
 D Instance show view should show past deployments
 D Deployments show view, index view
 D Deployables show view, index view
 D stop a deployment (set end_time on deployment) from deployments/show page
 D link from deployables/show (maybe also deployables/index) to make a new deployment from that deployable
 D should be able to see services deployed to a Host
 D also, should be able to generate a history of a Host wrt services
 D at some point, deal with audits and audit deployments
 D so a rollback is an attempt to cancel a Deployment and make another Deployment current.  This seems like copying a Deployment from the past, setting the start time to now.
 
 D be able to look at puppet manifest for a Host on the website
 - be able to specify what processor manages a host (puppet, chef, shell scripts, none of the above, etc.)
 
 - deployment config for the larry app; host this shit somewhere
 
 ---

 P create pool (name, description)
  P validate pool name presence, uniqueness
 P hosts many:many with pool (:through model: PoolMembership)
 P pool menu links
 P pool index view
 P pool new view, pool edit view
 P pool show view (includes hosts)
 P hosts show view includes pool memberships
 P pool show view should allow adding host, removing hosts
 P host show view should allow adding to pool, removing from pool
 P deployments/new has a Pool chooser (requires a Pool)

 ---

 P we can provision hosts that don't exist
 P we can provision hosts into a pool
 P we can ask a pool to provision hosts
 P hosts can have capacities, so that we can estimate whether we have enough capacity for deploying instances
 P instances can have costs, so that we can determine if we have sufficient host resources to deploy instances
 P should be able to determine if a pool has sufficient capacity to deploy instance(s)
 P should be able to recommend hosts to provision
 P [ provision would be via rubycloud, etc. ]
 P when deploying, should recommend hosts for instances, but provide a way to choose another host, or to provision a new host.
 P provisioning is based on capacity/cost, fwiw
 P could presumably associate a floor capacity w/ a Role
 P Requirement model specifies which capacities, roles, etc., will satisfy a deployment attempt

 thoughts:
 

 P should be able to specify that certain instances not reside on the same host
 P should be able to specify that certain instances should reside on the same host
 P should be able to specify that a service (or at least, an audit) should be on the same host as another (think log rotation, e.g.)
 P may want to be able to specify that a services (or at least, an audit) should not be on the same host as another ... or maybe it's that audits have their own Requirements for deployment?
 - we can mark various things (instance, app, customer, host, ?) as "dirty" on changes, and save them up for a deployment, so that we can know if our planned changes have been put into action, know when we need to make a deployment, can batch up changes, and keep the process of creating deployments separate from the data which is used to do current production deployments
 - could have indexes highlight strange situations:  customers with undeployed apps, hosts with no deployments, apps which are not deployed, etc.
 - we can use an instance as a template; if we make a new instance we basically make the instance, set template_id (or whatever) to the template instance, then delegate things to the template; we make the template instance's parameter values be defaults (behind customer, app, instance).
 - presumably we could also template an app; we could either go the same route (have a template pointer to the template app), or we could just instantiate new instances using the old app's instances as template.
 - general facility to associate remote resources with a concept (maybe w/ a parser, and we can generate an RSS feed)
   -> add linkages to nagios details for a host, service, etc.
   -> add linkages from customers to invoicing, e.g.
   -> is it possible to link from apps (or instances) to github pages?
   -> is it possible to link apps / customer to trouble ticket pages?
   -> what about linking to PT, e.g.
 - favicon.ico, heh
 - since deployment records are captured we can run a tool like puppet consistently over them without fear of introducing changes
 - since deployment manifests can only change when a deployment is created or on the time-interval boundaries of the deployments, we don't have to continuously poll for changes (i.e., we could schedule and/or notify instead).

 - if we associate some sort of service category with an instance (e.g., "Database hosting", "Production Web Server, Smegme", etc.) we can apply rates to service categories, use the deployment history for the Instance(s) as a log of billable service, and invoice straight from this motherfucker.  Not only that, but it could be billable at the service level.

--- Questions
  
 Q: is the difference between a service that's required by many instances on a host (e.g., postgres) but which only really causes one installation to happen, vs. services that have the same name but differ in parameters and cause multiple things to happen (e.g., setting up a postgres *database* for an app) ... is this something larry needs to concern itself with, or do we just leverage the underlying management tool?  If we're using puppet, puppet can sort things out, but it's not clear that something like chef, e.g., can.

 Q - when we talk about customers and apps for a service, we can be talking about two different things:  apps which are referencing this service currently via an Instance<->Requirement<->Service relationship (whether deployed or not); or apps referencing this service because there's a Service -> DeployedService -> Deployment -> Deployable -> Instance -> App relationship, even if it's no longer configured that way for new deployments (i.e., that's the "old way").  Which would we want to really show?
